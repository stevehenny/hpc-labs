---
title: Hot Plate Simulation
lab: 5-8
---

## Objective

Adapt or rewrite the simulation to run in parallel.

## Prerequisites

Before starting this lab, make sure that:

- You have read Kirk, PMPP Ch 5.3 and Ch 7

## Instructions

This lab is different from the previous labs in that you are given fully functioning sequential simulation code. Your goal is to adapt or rewrite the hot plate simulation to run in parallel using the target language and programming model. You are not directed with `//@@` comment lines where to make changes, but are expected to find your own path to parallelization from the sequential code. The hot plate simulation is intentionally simple so you can focus your time and effort on parallelization instead of trying to understand a complicated algorithm. However, understanding the algorithm and data usage patterns is necessary for constructing a performant parallel application. Refer to the Background section for more detail.

Issues to address when parallelizing the code:

- Use data decomposition to identify potential parallel processes or threads.
- Perform a reduction across each cell to determine if another iteration step in the simulation is necessary.
- Make sure the iteration step count is accurately incremented without a race condition between processes. The iteration count must be printed by the parallel version of your program before termination.

Input images of various sizes are generated by the dataset generator application. These images in .pgm format can be viewed with the default image viewer on the system. Each pixel of the gray scale image is represented by a value from 0 to 255. When these images are loaded from a file by the htk library, they are converted into an array of floating-point numbers that range from 0.0 to 1.0 in value. The simulation is then performed with floating-point numbers. When complete, simulation results are then saved to an image file. In the process, numbers are converted back to 8-bit integer values.

The executable generated as a result of compiling the lab can be run using the following command:

```
./solution -e <expected.pgm> -i <input.pgm> -o <output.pgm> -t image
```

where `<expected.pgm>` is the expected output, `<input.pgm>` is the input image, and `<output.pgm>` is an optional path to store the results. The datasets can be generated using the dataset generator built as part of the compilation process. Alternatively, just type `make run`.

## Background
```
  This code solves the steady state heat equation on a rectangular region.

  The border cells of the region have extreme temperatures, while the
  interior cells are temperate. The physical region, and the boundary
  conditions, are suggested by this diagram:

                 W = 0
           +------------------+
           |                  |
  W = 212  |     W = 72       | W = 212
           |                  |
           +------------------+
                 W = 212

  The region is covered with a grid of M by N nodes, and an M by N
  array W is used to record the temperature. The correspondence between
  array indices and locations in the region is suggested by giving the
  indices of the four corners:

                I = 0
        [0][0]-------------[0][N-1]
           |                  |
    J = 0  |                  |  J = N-1
           |                  |
      [M-1][0]-----------[M-1][N-1]
                I = M-1

  The steady state solution to the discrete heat equation satisfies the
  following condition at an interior grid point:

    W[Central] = (1/4) * ( W[North] + W[South] + W[East] + W[West] )

  where "Central" is the index of the grid point, "North" is the index
  of its immediate neighbor to the "north", and so on.

  Given an approximate solution of the steady state heat equation, a
  "better" solution is given by replacing each interior point by the
  average of its 4 neighbors - in other words, by using the condition
  as an ASSIGNMENT statement:

    W[Central]  <=  (1/4) * ( W[North] + W[South] + W[East] + W[West] )

  If this process is repeated often enough, the difference between successive
  estimates of the solution will go to zero.

  This program carries out such an iteration, using a tolerance specified by
  the user (epsilon), and writes the final estimate of the solution to a file
  that can be used for graphic processing.

  Notice that the stencil dimensions are 3x3 in width and height. Only the
  interior points of the solution grid are updated on each iteration step,
  so there is no need to handle ghost cells. The outer cells, one wide, are
  not updated and remain at their original values throughout the simulation.

  The input and output arrays are used alternately to hold the results of
  each iteration step. The pointers "u" and "w", which point to these arrays,
  are swapped after each step.

    U[i][j], the solution at the previous iteration.
    W[i][j], the solution computed at the latest iteration.

  The local variable "run" is updated each iteration with an OR reduction
  across all grid points. If any cell update changes by more than epsilon,
  "run" will be true, signaling another iteration is needed.

  A global variable "iterations" is maintained with the total count of steps
  taken toward a solution.

Licensing:

  This code is distributed under the GNU LGPL license.

Author:

  Original C version by Michael Quinn.

Reference:

  Michael Quinn,
  Parallel Programming in C with MPI and OpenMP,
  McGraw-Hill, 2004,
  ISBN13: 978-0071232654,
  LC: QA76.73.C15.Q55.

```
